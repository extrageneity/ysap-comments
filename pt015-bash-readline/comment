Episode 15 - CLI Tips and Tricks (with readline) to Optimize your Workflow

This episode centers around the GNU Readline, which is a common underlying library shared by bash and a number of other GNU utilities including emacs. So far everything Dave has demoed, even the stuff built for interactive mode, has dealt with bash operating primarily in a "line mode," where what you type out character-by-character is of no interest to the shell until after you finalize it and press enter. Readline breaks from that, in order to implement interactive command lines, by caring about the data you send to your terminal keystroke by keystroke rather than line-by-line.

Readline is effectively the "operating system" which is in effect prior to a line being sent into bash for interpretation at the script/code level, watching what you do one keypress at a time. It generally won't know if you have pressed a chording key such as shift/control or not, but any time you press a chord which causes your terminal emulator to send input to your terminal, readline is the part of the bash codebase which interprets that character of input. Readline permits key-bindings such as the ones Dave demonstrates, and also interoperates with a number of other bash features including those for tab completion and editable command history.

The bindings Dave shows (and I call them bindings here because that's the terminology in Bash documentation; other programs on desktop operating systems often instead refer to these as "hotkeys") are part of the Emacs-style readline bindings enabled in bash by default, and after 'set -o emacs'. You can instead get a vi-style binding using 'set -o vi', which gives you the ability to enter a control mode by pressing escape and then navigating your command line using all the same keys and functions that are available to you in vi. This is my mode of preference.

readline configuration is govered by your inputrc file, usually ~/.inputrc but sometimes elsewhere depending on how your system administrator or OS packager has built and configured bash. It has documentation under the 'READLINE' section of your bash man page, and in Chapter 8 of the Bash Reference Manual, Command Line Editing.

A key thing to understand when interacting with bash which can vary widely depending on your operating environment is how the 'meta' key which readline expects is received from your terminal. Most decent terminal emulators include a setting which let you bind (in the more conventional OS application sense) the key which will be sent as Meta, and there is a separate key sequence for 'Alt' which is distinct from Meta and can be sent over a terminal. 

You can customize your environment to make profound changes to your interactive bash command lines, including some limited syntax highlighting for commands, fresh bindings, even full macros. Other than your .inputrc file, you can also interact with these commands using the 'bind' command. If you want to learn more about how to change this environment, start with Chapter 8 of the reference manual, while you have a terminal open, and as you read the docs, periodically compare what you're reading with the output of 'bind -p', which lists all the bindings currently applicable to your environment.

I tend not to change the stock bindings for a bash shell at all, because it can be disorienting if your shell bindings change from one host to another, or one user to another on hosts where you are using sudo and su to switch users to various role accounts including the root user. If your usage pattern varies from that, for example primarily interacting with your shell via a terminal running locally on a MacOS or Linux desktop, you may want to consider far deeper customizations, _especially_ if you also plan to make significant investment in programmable completion (i.e. the "tab" key becomes a contextual do-what-I-mean button, completing far more than simple filenames). Learning how to interact with the built in "kill-ring" included in Readline to do copy-and-paste without relying on the local clipboard of the desktop where your terminal is running can be a godsend in certain cases. 

Do you suck at programming if you don't know this stuff? To a certain extent, yes! This is an area in bash where you probably don't need to go anywhere near as deep as the shell lets you, but knowing even the visible part of the readline iceberg can definitely make you both a better shell operator and a better bash programmer.Good programmers are able to work quickly. Working quickly in a command line environment requires you to be able to produce and modify the commands you enter quickly, without having to resort to strategies like copy-and-paste or manual re-entry of botched lines. Understanding how to interact with both readline and the history facility are critical to improving your bash operating speed. This is especially true if you are often interacting with bash via ssh or via a terminal emulator, versus interacting with it using something like an embedded terminal on an IDE which might include its own command line history features independent from your shell.

Happy command line editing!
